<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Informações Pessoais</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">

    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        html {
            font-size: 1.75vh;
        }

        body {
            background-color: #000; /* Fallback caso o canvas não carregue */
            color: #fff;
            font-family: "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1.25rem;
            overflow: hidden;
        }

        /* Estilo para o canvas do background */
        #glcanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Coloca o canvas atrás de todo o conteúdo */
            display: block;
        }

        .main-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10rem;
            width: 100%;
            max-width: 95rem;
            padding: 0 2rem;
            position: relative; /* Garante que o conteúdo fique sobre o canvas */
            z-index: 1;
        }

        .container {
            width: 100%;
            max-width: 23.75rem;
            flex-shrink: 0;
        }

        .mannequin-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .mannequin-container img {
            max-height: 45rem;
            width: auto;
            object-fit: contain;
        }

        h1 {
            font-size: 1.875rem;
            font-weight: 500;
            margin-bottom: 1.25rem;
        }

        input::placeholder { color: #8e8e93; opacity: 1; }
        input[type="text"] {
            background-color: transparent;
            border: none;
            color: #fff;
            font-size: 1.125rem;
            padding: 0.5rem 0.125rem;
            width: 100%;
        }
        input[type="text"]:focus { outline: none; }

        .input-with-suffix {
            display: flex; align-items: baseline;
            border-bottom: 0.0625rem solid #666;
            padding-bottom: 0;
        }
        .input-with-suffix:focus-within { border-bottom-color: #fff; }
        .input-with-suffix .suffix {
            font-size: 1.125rem;
            color: #8e8e93;
            margin-left: 0.3125rem;
        }

        .form-group {
            border-bottom: 0.0625rem solid #666;
            padding-bottom: 0;
        }
        .form-group:focus-within { border-bottom-color: #fff; }

        .measurements-row {
            display: flex; justify-content: space-between; align-items: flex-end;
            margin-top: 1.25rem;
        }
        .height-weight-group {
            display: flex; flex-direction: column;
            gap: 1.25rem;
        }
        .height-weight-group .input-with-suffix {
            width: 5.9375rem;
        }

        .sex-group {
            display: flex; align-items: center;
            gap: 0.9375rem;
        }
        .sex-label {
            font-size: 1.125rem;
            flex-shrink: 0;
        }
        .sex-options {
            display: flex;
            gap: 0.625rem;
        }
        .sex-btn {
            background-color: #3a3a3a; border: none;
            border-radius: 0.75rem;
            width: 3.4375rem; height: 3.4375rem;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
        }
        .sex-btn img {
            width: 1.75rem; height: 1.75rem;
        }

        .size-area {
            position: relative;
            margin-top: 1.875rem;
        }

        .size-selector {
            display: flex; justify-content: space-between; align-items: center;
            position: relative;
            z-index: 2;
        }
        .size-btn {
            background-color: #3a3a3a; border: none;
            border-radius: 0.75rem;
            width: 3.4375rem; height: 3.4375rem;
            color: #fff;
            font-size: 1.125rem;
            font-weight: 500;
            display: flex; justify-content: center; align-items: center; cursor: pointer;
        }
        .size-btn img {
            width: 1.75rem; height: 1.75rem;
        }

        .info-text {
            margin-top: 3.125rem;
            position: relative;
            z-index: 2;
        }
        .info-text p {
            font-size: 1.125rem;
            line-height: 1.4;
        }
        #text1 {
            margin-bottom: 1.875rem;
        }

        .submit-btn {
            background-color: #3a3a3a; border: none;
            border-radius: 0.9375rem;
            width: 100%;
            padding: 1.125rem;
            color: #fff;
            font-size: 1.125rem;
            font-weight: 500;
            cursor: pointer;
            margin-top: 2.1875rem;
        }

        .svg-wrapper {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }
        svg.overlay {
            width: 100%;
            height: 100%;
            display: block;
            overflow: visible;
        }

    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <div class="main-wrapper">
        <div class="container">
            <h1>Informações Pessoais</h1>

            <form onsubmit="return false;">
                <div class="form-group">
                    <input type="text" id="nome" placeholder="Nome" />
                </div>

                <div class="measurements-row">
                    <div class="height-weight-group">
                        <div class="input-with-suffix">
                            <input type="text" id="altura" placeholder="Altura" inputmode="decimal" data-decimals="2" />
                            <span class="suffix">m</span>
                        </div>
                        <div class="input-with-suffix">
                            <input type="text" id="peso" placeholder="Peso" inputmode="decimal" data-decimals="2" />
                            <span class="suffix">kg</span>
                        </div>
                    </div>

                    <div class="sex-group">
                        <span class="sex-label">Sexo</span>
                        <div class="sex-options">
                            <button type="button" class="sex-btn" aria-label="feminino">
                                <img src="images/female.png" alt="Símbolo Feminino">
                            </button>
                            <button type="button" class="sex-btn" aria-label="masculino">
                                <img src="images/male.png" alt="Símbolo Masculino">
                            </button>
                        </div>
                    </div>
                </div>

                <div class="size-area">
                    <div class="svg-wrapper" aria-hidden="true">
                        <svg class="overlay" xmlns="http://www.w3.org/2000/svg"></svg>
                    </div>

                    <div class="size-selector">
                        <button type="button" class="size-btn" id="sizePP">PP</button>
                        <button type="button" class="size-btn" id="sizeP">P</button>
                        <button type="button" class="size-btn" id="sizeM">M</button>
                        <button type="button" class="size-btn" id="sizeG">G</button>
                        <button type="button" class="size-btn" id="sizeGG">GG</button>
                        <button type="button" class="size-btn" id="custom-size" aria-label="personalizado">
                            <img src="images/customized.png" alt="Símbolo de Medidas Customizadas">
                        </button>
                    </div>

                    <div class="info-text">
                        <p id="text1">Você pode selecionar um<br>tamanho predefinido</p>
                        <p id="text2">Ou informar suas medidas<br>exatas (recomendado)</p>
                    </div>
                </div>

                <button type="submit" class="submit-btn">Enviar suas medidas</button>
            </form>
        </div>

        <div class="mannequin-container">
            <img src="images/tposefem-full.png" alt="Manequim 3D para referência de medidas">
        </div>
    </div>

    <script>
        // --- INÍCIO DO SCRIPT DO BACKGROUND HOLOGRÁFICO ---
        const HOLO_PARAMS = {
          scale: 0.94,
          ax: 1.0,
          ay: 1.0,
          az: 3.0,
          aw: 2.0,
          bx: 2.0,
          by: 1.0,
          color1: '#ffffff',
          color2: '#ff0099',
          color3: '#00ff7b',
          color4: '#7b00ff'
        };

        const vsSource = `
        attribute vec2 a_position;
        varying vec2 vUv;
        void main() {
          vUv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
        `;

        const fsSource = `
        precision highp float;
        varying vec2 vUv;
        uniform float u_time;
        uniform vec2 u_resolution;
        uniform float u_scale;
        uniform vec3 u_color1;
        uniform vec3 u_color2;
        uniform vec3 u_color3;
        uniform vec3 u_color4;
        uniform float u_ax;
        uniform float u_ay;
        uniform float u_az;
        uniform float u_aw;
        uniform float u_bx;
        uniform float u_by;

        float cheapNoise(vec3 stp) {
          vec3 p = stp;
          vec4 a = vec4(u_ax, u_ay, u_az, u_aw);
          return mix(
            sin(p.z + p.x * a.x + cos(p.x * a.x - p.z)) *
            cos(p.z + p.y * a.y + cos(p.y * a.x + p.z)),
            sin(1. + p.x * a.z + p.z + cos(p.y * a.w - p.z)) *
            cos(1. + p.y * a.w + p.z + cos(p.x * a.x + p.z)),
            .436
          );
        }

        void main() {
          vec2 aR = vec2(u_resolution.x/u_resolution.y, 1.);
          vec2 st = vUv * aR * u_scale;
          float S = sin(u_time * .005);
          float C = cos(u_time * .005);
          vec2 v1 = vec2(cheapNoise(vec3(st, 2.)), cheapNoise(vec3(st, 1.)));
          vec2 v2 = vec2(
            cheapNoise(vec3(st + u_bx * v1 + vec2(C * 1.7, S * 9.2), 0.15 * u_time)),
            cheapNoise(vec3(st + u_by * v1 + vec2(S * 8.3, C * 2.8), 0.126 * u_time))
          );
          float n = .5 + .5 * cheapNoise(vec3(st + v2, 0.));
          vec3 color = mix(u_color1, u_color2, clamp((n*n)*8.,0.0,1.0));
          color = mix(color, u_color3, clamp(length(v1),0.0,1.0));
          color = mix(color, u_color4, clamp(length(v2.x),0.0,1.0));
          color /= n*n + n * 7.;
          gl_FragColor = vec4(color,1.);
        }
        `;

        function hexToRgbNormalized(hex) {
          const h = hex.replace('#','');
          const bigint = parseInt(h.length === 3 ? h.split('').map(c=>c+c).join('') : h, 16);
          const r = (bigint >> 16) & 255;
          const g = (bigint >> 8) & 255;
          const b = bigint & 255;
          return [r/255, g/255, b/255];
        }

        function createShader(gl, type, source) {
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const msg = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error('Shader compile error: ' + msg);
          }
          return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
          const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
          const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
          const program = gl.createProgram();
          gl.attachShader(program, vs);
          gl.attachShader(program, fs);
          gl.linkProgram(program);
          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            const msg = gl.getProgramInfoLog(program);
            gl.deleteProgram(program);
            throw new Error('Program link error: ' + msg);
          }
          return program;
        }

        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl', { antialias: true });
        if (!gl) {
          // Esconde o canvas e usa o background preto do body
          canvas.style.display = 'none';
          console.error('WebGL não suportado');
        } else {
            const program = createProgram(gl, vsSource, fsSource);
            gl.useProgram(program);

            const posLoc = gl.getAttribLocation(program, 'a_position');
            const timeLoc = gl.getUniformLocation(program, 'u_time');
            const resLoc = gl.getUniformLocation(program, 'u_resolution');
            const scaleLoc = gl.getUniformLocation(program, 'u_scale');
            const axLoc = gl.getUniformLocation(program, 'u_ax');
            const ayLoc = gl.getUniformLocation(program, 'u_ay');
            const azLoc = gl.getUniformLocation(program, 'u_az');
            const awLoc = gl.getUniformLocation(program, 'u_aw');
            const bxLoc = gl.getUniformLocation(program, 'u_bx');
            const byLoc = gl.getUniformLocation(program, 'u_by');
            const c1Loc = gl.getUniformLocation(program, 'u_color1');
            const c2Loc = gl.getUniformLocation(program, 'u_color2');
            const c3Loc = gl.getUniformLocation(program, 'u_color3');
            const c4Loc = gl.getUniformLocation(program, 'u_color4');

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            const vertices = new Float32Array([
              -1, -1,  1, -1, -1, 1,
              -1,  1,  1, -1,  1, 1
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            function resize() {
              const dpr = window.devicePixelRatio || 1;
              const width = Math.floor(canvas.clientWidth * dpr);
              const height = Math.floor(canvas.clientHeight * dpr);
              if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0,0,canvas.width,canvas.height);
              }
            }

            const color1 = hexToRgbNormalized(HOLO_PARAMS.color1);
            const color2 = hexToRgbNormalized(HOLO_PARAMS.color2);
            const color3 = hexToRgbNormalized(HOLO_PARAMS.color3);
            const color4 = hexToRgbNormalized(HOLO_PARAMS.color4);

            gl.uniform3fv(c1Loc, new Float32Array(color1));
            gl.uniform3fv(c2Loc, new Float32Array(color2));
            gl.uniform3fv(c3Loc, new Float32Array(color3));
            gl.uniform3fv(c4Loc, new Float32Array(color4));
            gl.uniform1f(scaleLoc, HOLO_PARAMS.scale);
            gl.uniform1f(axLoc, HOLO_PARAMS.ax);
            gl.uniform1f(ayLoc, HOLO_PARAMS.ay);
            gl.uniform1f(azLoc, HOLO_PARAMS.az);
            gl.uniform1f(awLoc, HOLO_PARAMS.aw);
            gl.uniform1f(bxLoc, HOLO_PARAMS.bx);
            gl.uniform1f(byLoc, HOLO_PARAMS.by);

            let start = Date.now();

            function render() {
              resize();
              const now = Date.now();
              const t = (now - start);
              gl.uniform1f(timeLoc, t * 0.0025);
              gl.uniform2f(resLoc, canvas.width, canvas.height);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }
        // --- FIM DO SCRIPT DO BACKGROUND HOLOGRÁFICO ---


        // --- INÍCIO DO SCRIPT ORIGINAL DA PÁGINA ---
        function drawLines() {
            const svg = document.querySelector("svg.overlay");
            if (!svg) return;
            svg.innerHTML = "";

            const btnPP = document.getElementById("sizePP");
            const btnGG = document.getElementById("sizeGG");
            
            const btnM = document.getElementById("sizeM");
            const btnCustom = document.getElementById("custom-size");
            const text1 = document.getElementById("text1");
            const text2 = document.getElementById("text2");

            if (!btnPP || !btnGG || !btnM || !btnCustom || !text1 || !text2) return;

            const rem = parseFloat(getComputedStyle(document.documentElement).fontSize);
            
            const strokeWidth = 0.05 * rem;

            const svgRect = svg.getBoundingClientRect();
            const rectPP = btnPP.getBoundingClientRect();
            const rectGG = btnGG.getBoundingClientRect();
            const rectM = btnM.getBoundingClientRect();
            const rectCustom = btnCustom.getBoundingClientRect();
            const rectT1 = text1.getBoundingClientRect();
            const rectT2 = text2.getBoundingClientRect();

            const toSvgX = (r) => r.left - svgRect.left + (r.width / 2);
            const toSvgY = (r) => r.top - svgRect.top;

            const buttonsY = toSvgY(rectPP) + rectPP.height + (1.5 * rem);

            const mainLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            const lineStartX = rectPP.left - svgRect.left;
            const lineEndX = (rectGG.left - svgRect.left) + rectGG.width;
            
            mainLine.setAttribute("x1", lineStartX);
            mainLine.setAttribute("y1", buttonsY);
            mainLine.setAttribute("x2", lineEndX);
            mainLine.setAttribute("y2", buttonsY);
            mainLine.setAttribute("stroke", "white");
            mainLine.setAttribute("stroke-width", strokeWidth);
            svg.appendChild(mainLine);

            const midX = toSvgX(rectM);
            const text1Y = toSvgY(rectT1);
            const vertical1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            vertical1.setAttribute("x1", midX);
            vertical1.setAttribute("y1", buttonsY);
            vertical1.setAttribute("x2", midX);
            vertical1.setAttribute("y2", text1Y - (0.5 * rem));
            vertical1.setAttribute("stroke", "white");
            vertical1.setAttribute("stroke-width", strokeWidth);
            svg.appendChild(vertical1);

            const customX = toSvgX(rectCustom);
            const text2Y = toSvgY(rectT2) + (rectT2.height / 2);
            const vertical2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            vertical2.setAttribute("x1", customX);
            vertical2.setAttribute("y1", buttonsY);
            vertical2.setAttribute("x2", customX);
            vertical2.setAttribute("y2", text2Y);
            vertical2.setAttribute("stroke", "white");
            vertical2.setAttribute("stroke-width", strokeWidth);
            svg.appendChild(vertical2);

            const text2StartX = toSvgX(rectT2) - (rectT2.width / 1.13);
            const horizontal2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            horizontal2.setAttribute("x1", customX);
            horizontal2.setAttribute("y1", text2Y);
            horizontal2.setAttribute("x2", text2StartX + rectT2.width);
            horizontal2.setAttribute("y2", text2Y);
            horizontal2.setAttribute("stroke", "white");
            horizontal2.setAttribute("stroke-width", strokeWidth);
            svg.appendChild(horizontal2);
        }

        let resizeTimer;
        window.addEventListener("resize", () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(drawLines, 100);
        });
        window.addEventListener("load", () => {
            setTimeout(drawLines, 100);
        });
        drawLines();

        document.addEventListener('DOMContentLoaded', () => {
            const formatOnInput = (inputEl, maxDigits) => {
                let rawValue = inputEl.value.replace(/\D/g, '');
                if (rawValue.length > maxDigits) {
                    rawValue = rawValue.slice(-maxDigits);
                }
                if (rawValue === '') {
                    inputEl.value = '';
                    return;
                }
                const decimals = parseInt(inputEl.dataset.decimals, 10) || 0;
                const paddedValue = rawValue.padStart(decimals + 1, '0');
                const decimalIndex = paddedValue.length - decimals;
                const integerPart = parseInt(paddedValue.substring(0, decimalIndex), 10) || 0;
                const decimalPart = paddedValue.substring(decimalIndex);
                inputEl.value = decimals > 0 ? `${integerPart},${decimalPart}` : `${integerPart}`;
            };

            const checkOnBlur = (inputEl) => {
                if (inputEl.value === '0,00' || inputEl.value === '0,0' || inputEl.value === '0') {
                    inputEl.value = '';
                }
            };

            const alturaInput = document.getElementById('altura');
            const pesoInput = document.getElementById('peso');

            if (alturaInput) {
                alturaInput.addEventListener('input', () => formatOnInput(alturaInput, 3));
                alturaInput.addEventListener('blur', () => checkOnBlur(alturaInput));
            }
            if (pesoInput) {
                pesoInput.addEventListener('input', () => formatOnInput(pesoInput, 5));
                pesoInput.addEventListener('blur', () => checkOnBlur(pesoInput));
            }
        });
    </script>
</body>
</html>